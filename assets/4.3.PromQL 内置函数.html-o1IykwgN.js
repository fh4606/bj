import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,o as s,d as a}from"./app-fmcy30Ms.js";const t="/assets/2023-10-28_210148_3969810.8486196271337566-D19xcv31.png",n={},l=a(`<h2 id="数学函数" tabindex="-1"><a class="header-anchor" href="#数学函数"><span>数学函数</span></a></h2><p>数学函数对瞬时向量执行标准的数学运算，如计算绝对值或取对数。瞬时向量中的每个样本都是独立处理的，并且在返回值中删除指标名称。<br> （1）abs()<br> 该函数输入瞬时向量，返回其每个值的绝对值。例如，对于表达式process_open_fds，调试后返回信息为：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>process_open_fds{instance=&quot;localhost:9090&quot;,job=&quot;prometheus&quot;}        	18</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>使用函数表达式<code>abs(process_open_fds-19)</code>和<code>abs(process_open_fds-17)</code>求绝对值后返回信息为：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span> {instance=&quot;localhost:9090&quot;,job=&quot;prometheus&quot;}        1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>（2）sqrt()<br> 该函数返回瞬时向量中值的平方根，例如表达式<code>sqrt(vector(25))</code>，返回结果为：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span> {}        5</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>（3）round()</p><p>该函数将瞬时向量中的值四舍五入到最近的整数。例如表达式<code>round(vector(7.5))</code>，返回结果为：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span> {}        8</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="时间函数" tabindex="-1"><a class="header-anchor" href="#时间函数"><span>时间函数</span></a></h2><p>Prometheus使用的是协调世界时（UTC），没有时区的概念。为了使用户在使用中不用自己实现与日期相关的逻辑，Prometheus提供了一些时间函数。<br> （1）time()<br> 该函数是最基本的时间函数，它将查询的计算时间以秒为单位返回。</p><p>例如，查看进程运行了多长时间，可以使用表达式：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>time()-process_start_time_seconds</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>结果</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>{instance=&quot;localhost:9090&quot;, job=&quot;prometheus&quot;}         3137.62700009346</span></span>
<span class="line"><span>{instance=&quot;node_exporter:9100&quot;, job=&quot;node-exporter&quot;}  3138.367000102997</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>触发器案例:证书还有30天到期</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>probe_ssl_earliest_cert_expiry - time() &lt; 86400 * 30</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="计算counter指标增长率函数" tabindex="-1"><a class="header-anchor" href="#计算counter指标增长率函数"><span>计算Counter指标增长率函数</span></a></h2><p>我们知道Counter类型的监控指标其特点是只增不减，在没有发生重置（如服务器重启，应用重启）的情况下其样本值应该是不断增大的。为了能够更直观</p><p>++的表示样本数据的变化剧烈情况，需要计算样本的增长速率。</p><p>如下图所示，样本增长率反映出了样本变化的剧烈程度：</p><figure><img src="`+t+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>通过增长率表示样本的变化情况</p><p>increase(v range-vector)函数是PromQL中提供的众多内置函数之一。其中参数v是一个区间向量，increase函数获取区间向量中的第一个后最后一个样本并返回其增长量。因此，可以通过以下表达式Counter类型指标的增长率：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>increase(node_load1[2m]) / 120</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这里通过node_cpu[2m]获取时间序列最近两分钟的所有样本，increase计算出最近两分钟的增长量，最后除以时间120秒得到node_cpu样本在最近两分钟的平均增长率。并且这个值也近似于主机节点最近两分钟内的平均CPU使用率。</p><p>除了使用increase函数以外，PromQL中还直接内置了rate(v range-vector)函数，rate函数可以直接计算区间向量v在时间窗口内平均增长速率。因此，通过以下表达式可以得到与increase函数相同的结果：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>rate(node_load1[2m])</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>需要注意的是使用rate或者increase函数去计算样本的平均增长速率，容易陷入“长尾问题”当中，其无法反应在时间窗口内样本数据的突发变化。 例如，对于主机而言在2分钟的时间窗口内，可能在某一个由于访问量或者其它问题导致CPU占用100%的情况，但是通过计算在时间窗口内的平均增长率却无法反应出该问题。</p><p>为了解决该问题，PromQL提供了另外一个灵敏度更高的函数irate(v range-vector)。irate同样用于计算区间向量的计算率，但是其反应出的是瞬时增长率。irate函数是通过区间向量中最后两个样本数据来计算区间向量的增长速率。这种方式可以避免在时间窗口范围内的“长尾问题”，并且体现出更好的灵敏度，通过irate函数绘制的图标能够更好的反应样本数据的瞬时变化状态。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>irate(node_load1[2m])</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>irate函数相比于rate函数提供了更高的灵敏度，不过当需要分析长期趋势或者在告警规则中，irate的这种灵敏度反而容易造成干扰。因此在长期趋势分析或者告警中更推荐使用rate函数。</p><h2 id="预测gauge指标变化趋势函数" tabindex="-1"><a class="header-anchor" href="#预测gauge指标变化趋势函数"><span>预测Gauge指标变化趋势函数</span></a></h2><p>在一般情况下，系统管理员为了确保业务的持续可用运行，会针对服务器的资源设置相应的告警阈值。例如，当磁盘空间只剩512MB时向相关人员发送告警通知。 这种基于阈值的告警模式对于当资源用量是平滑增长的情况下是能够有效的工作的。 但是如果资源不是平滑变化的呢？ 比如有些某些业务增长，存储空间的增长速率提升了高几倍。这时，如果基于原有阈值去触发告警，当系统管理员接收到告警以后可能还没来得及去处理问题，系统就已经不可用了。 因此阈值通常来说不是固定的，需要定期进行调整才能保证该告警阈值能够发挥去作用。 那么还有没有更好的方法吗？</p><p>PromQL中内置的predict_linear(v range-vector, t scalar) 函数可以帮助系统管理员更好的处理此类情况，predict_linear函数可以预测时间序列v在t秒后的值。它基于简单线性回归的方式，对时间窗口内的样本数据进行统计，从而可以对时间序列的变化趋势做出预测。例如，基于1小时的样本数据，来预测主机可用磁盘空间的是否在24个小时候被占满，可以使用如下表达式：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>predict_linear(node_filesystem_avail_bytes{fstype!~&quot;tmpfs&quot;}[1h], 24 * 3600) &lt; 0</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>node_exporter触发器解释</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>(node_filesystem_avail_bytes * 100) / node_filesystem_size_bytes &lt; 10 and ON (instance, device, mountpoint) predict_linear(node_filesystem_avail_bytes{fstype!~&quot;tmpfs&quot;}[1h], 24 * 3600) &lt; 0 and ON (instance, device, mountpoint) node_filesystem_readonly == 0</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>磁盘可用率&lt;10% 并且 基于1小时的样本数据，来预测主机可用磁盘空间的是否在24个小时候被占满 并且 文件系统不等于只读</p><p><code>node_filesystem_readonly</code> ：只读文件系统</p><p><code>node_filesystem_avail_bytes</code>: 磁盘剩余空间大小（字节）</p><p><code>node_filesystem_size_bytes</code>: 磁盘总大小（字节）</p><h2 id="标签操作函数" tabindex="-1"><a class="header-anchor" href="#标签操作函数"><span>标签操作函数</span></a></h2><p>一般来说来说，使用PromQL查询到时间序列后，可视化工具会根据时间序列的标签来渲染图表。例如通过up指标可以获取到当前所有运行的Exporter实例以及其状态：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>up{instance=&quot;192.168.11.61&quot;, job=&quot;blackbox_icmp&quot;}            1</span></span>
<span class="line"><span>up{instance=&quot;192.168.11.61:22&quot;, job=&quot;blackbox_tcp&quot;}          1</span></span>
<span class="line"><span>up{instance=&quot;192.168.11.61:9090&quot;, job=&quot;blackbox_tcp&quot;}        1</span></span>
<span class="line"><span>up{instance=&quot;192.168.11.62&quot;, job=&quot;blackbox_icmp&quot;}            1</span></span>
<span class="line"><span>up{instance=&quot;192.168.11.62:8081&quot;, job=&quot;springboot-demo&quot;}     1</span></span>
<span class="line"><span>up{instance=&quot;192.168.11.62:9222&quot;, job=&quot;domain&quot;}              1</span></span>
<span class="line"><span>up{instance=&quot;192.168.11.62:9256&quot;, job=&quot;process&quot;}             1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这是可视化工具渲染图标时可能根据，instance和job的值进行渲染，为了能够让客户端的图标更具有可读性，可以通过label_replace标签为时间序列添加额外的标签。label_replace的具体参数如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>label_replace(v instant-vector, dst_label string, replacement string, src_label string, regex string)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>该函数会依次对v中的每一条时间序列进行处理，通过regex匹配src_label的值，并将匹配部分relacement写入到dst_label标签中。如下所示：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>label_replace(up, &quot;host&quot;, &quot;$1&quot;, &quot;instance&quot;,  &quot;(.*):.*&quot;)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>函数处理后，时间序列将包含一个host标签，host标签的值为Exporter实例的IP地址：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>up{instance=&quot;192.168.11.61&quot;, job=&quot;blackbox_icmp&quot;}                              1</span></span>
<span class="line"><span>up{host=&quot;192.168.11.61&quot;, instance=&quot;192.168.11.61:22&quot;, job=&quot;blackbox_tcp&quot;}      1</span></span>
<span class="line"><span>up{host=&quot;192.168.11.61&quot;, instance=&quot;192.168.11.61:9090&quot;, job=&quot;blackbox_tcp&quot;}    1</span></span>
<span class="line"><span>up{instance=&quot;192.168.11.62&quot;, job=&quot;blackbox_icmp&quot;}                              1</span></span>
<span class="line"><span>up{host=&quot;192.168.11.62&quot;, instance=&quot;192.168.11.62:8081&quot;, job=&quot;springboot-demo&quot;} 1</span></span>
<span class="line"><span>up{host=&quot;192.168.11.62&quot;, instance=&quot;192.168.11.62:9222&quot;, job=&quot;domain&quot;}          1</span></span>
<span class="line"><span>up{host=&quot;192.168.11.62&quot;, instance=&quot;192.168.11.62:9256&quot;, job=&quot;process&quot;}         1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>除了label_replace以外，Prometheus还提供了label_join函数，该函数可以将时间序列中v多个标签src_label的值，通过separator作为连接符写入到一个新的标签dst_label中:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>label_join(v instant-vector, dst_label string, separator string, src_label_1 string, src_label_2 string, ...)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>表达式:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>up{instance=&quot;192.168.11.61&quot;, job=&quot;blackbox_icmp&quot;}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>使用label_join表达式：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>label_join(up{instance=&quot;192.168.11.61&quot;, job=&quot;blackbox_icmp&quot;},&quot;ip&quot;,&quot;,&quot;,&quot;job&quot;)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>label_replace和label_join函数提供了对时间序列标签的自定义能力，从而能够更好的于客户端或者可视化工具配合。</p><h2 id="其它内置函数" tabindex="-1"><a class="header-anchor" href="#其它内置函数"><span>其它内置函数</span></a></h2><p>除了上文介绍的这些内置函数以外，PromQL还提供了大量的其它内置函数。这里就不一一细讲，感兴趣的同学可以通过阅读Prometheus的官方文档，了解这些函数的使用方式。</p><p><a href="https://prometheus.io/docs/prometheus/latest/querying/functions/" target="_blank" rel="noopener noreferrer">官方文档</a></p>`,62),r=[l];function o(d,p){return s(),i("div",null,r)}const u=e(n,[["render",o],["__file","4.3.PromQL 内置函数.html.vue"]]),b=JSON.parse('{"path":"/note/Prometheus/4.3.PromQL%20%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0.html","title":"4.3.PromQL 内置函数","lang":"zh-CN","frontmatter":{"title":"4.3.PromQL 内置函数","order":26,"icon":"lightbulb","description":"数学函数 数学函数对瞬时向量执行标准的数学运算，如计算绝对值或取对数。瞬时向量中的每个样本都是独立处理的，并且在返回值中删除指标名称。 （1）abs() 该函数输入瞬时向量，返回其每个值的绝对值。例如，对于表达式process_open_fds，调试后返回信息为： 使用函数表达式abs(process_open_fds-19)和abs(process_...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/note/Prometheus/4.3.PromQL%20%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0.html"}],["meta",{"property":"og:site_name","content":"风华"}],["meta",{"property":"og:title","content":"4.3.PromQL 内置函数"}],["meta",{"property":"og:description","content":"数学函数 数学函数对瞬时向量执行标准的数学运算，如计算绝对值或取对数。瞬时向量中的每个样本都是独立处理的，并且在返回值中删除指标名称。 （1）abs() 该函数输入瞬时向量，返回其每个值的绝对值。例如，对于表达式process_open_fds，调试后返回信息为： 使用函数表达式abs(process_open_fds-19)和abs(process_..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"风华"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"4.3.PromQL 内置函数\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"风华\\",\\"url\\":\\"/portfolio\\"}]}"]]},"headers":[{"level":2,"title":"数学函数","slug":"数学函数","link":"#数学函数","children":[]},{"level":2,"title":"时间函数","slug":"时间函数","link":"#时间函数","children":[]},{"level":2,"title":"计算Counter指标增长率函数","slug":"计算counter指标增长率函数","link":"#计算counter指标增长率函数","children":[]},{"level":2,"title":"预测Gauge指标变化趋势函数","slug":"预测gauge指标变化趋势函数","link":"#预测gauge指标变化趋势函数","children":[]},{"level":2,"title":"标签操作函数","slug":"标签操作函数","link":"#标签操作函数","children":[]},{"level":2,"title":"其它内置函数","slug":"其它内置函数","link":"#其它内置函数","children":[]}],"git":{},"readingTime":{"minutes":7.17,"words":2150},"filePathRelative":"note/Prometheus/4.3.PromQL 内置函数.md","autoDesc":true}');export{u as comp,b as data};
